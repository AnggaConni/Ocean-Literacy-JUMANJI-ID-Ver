<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jumanji: Geo-Literacy Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&family=Roboto+Mono:wght@400;700&family=Roboto:wght@400;700&display=swap');

        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Roboto', sans-serif; color: white; user-select: none; }
        
        /* --- SCREENS --- */
        .screen {
            position: fixed; inset: 0; z-index: 50;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: radial-gradient(circle at center, #0f172a 0%, #020617 100%);
            transition: opacity 0.5s;
        }
        .hidden { opacity: 0; pointer-events: none; }

        /* TITLE SCREEN */
        #title-screen h1 {
            font-family: 'Cinzel', serif; font-size: 4rem; color: #10b981; 
            text-shadow: 0 0 20px #10b981, 0 0 40px #064e3b; margin: 0; letter-spacing: 5px;
            text-transform: uppercase; text-align: center;
        }
        #title-screen h2 { font-family: 'Cinzel', serif; color: #94a3b8; letter-spacing: 3px; margin-top: 10px; font-size: 1.5rem; }
        
        .creator-name {
            font-family: 'Roboto Mono', monospace; font-size: 1rem; color: #fbbf24;
            margin-top: 20px; letter-spacing: 1px; border-top: 1px solid #fbbf24; padding-top: 10px;
        }

        .big-btn {
            margin-top: 40px; padding: 15px 50px; font-size: 1.5rem;
            background: linear-gradient(45deg, #fbbf24, #d97706); color: #000; border: none;
            font-family: 'Cinzel', serif; cursor: pointer; transition: all 0.3s;
            text-transform: uppercase; letter-spacing: 2px; border-radius: 50px;
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.4); font-weight: bold;
        }
        .big-btn:hover { transform: scale(1.1); box-shadow: 0 0 40px rgba(251, 191, 36, 0.8); }

        /* SETUP SCREEN */
        #setup-screen h2 { font-family: 'Cinzel', serif; font-size: 2rem; color: #fbbf24; margin-bottom: 30px; }
        .player-select { display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; }
        .p-opt-btn {
            width: 60px; height: 60px; border-radius: 50%; border: 2px solid #334155;
            background: #1e293b; color: white; font-size: 1.5rem; cursor: pointer;
            transition: all 0.2s; font-weight: bold; font-family: 'Cinzel', serif;
        }
        .p-opt-btn:hover { border-color: #10b981; background: #064e3b; transform: scale(1.1); }

        /* GAME UI LAYER */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;
            opacity: 0; transition: opacity 1s;
        }
        .ui-visible { opacity: 1 !important; }

        /* HUD Top */
        .hud-top {
            padding: 20px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
            display: flex; justify-content: space-between; align-items: flex-start; pointer-events: auto;
        }
        .mini-title { font-family: 'Cinzel', serif; color: #10b981; font-weight: bold; margin: 0; text-shadow: 0 0 5px black; }
        .player-list { background: rgba(15, 23, 42, 0.8); padding: 10px; border-radius: 8px; border: 1px solid #334155; backdrop-filter: blur(5px); }
        .player-item { display: flex; align-items: center; gap: 8px; margin-bottom: 4px; font-size: 0.9rem; font-family: 'Roboto Mono', monospace; }
        .p-dot { width: 12px; height: 12px; border-radius: 50%; display: inline-block; border: 1px solid white; }
        .active-turn { color: #fbbf24; font-weight: bold; text-shadow: 0 0 5px #fbbf24; }

        /* HUD Bottom */
        .hud-bottom {
            padding: 20px; text-align: center; pointer-events: auto;
            background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
            display: flex; flex-direction: column; align-items: center; gap: 10px;
        }
        #log-area {
            height: 80px; overflow-y: auto; width: 100%; max-width: 600px;
            background: rgba(0,0,0,0.6); font-size: 0.85rem; padding: 10px;
            border-left: 4px solid #10b981; text-align: left; font-family: 'Roboto Mono', monospace;
            border-radius: 4px; color: #e2e8f0;
        }
        #roll-btn {
            background: linear-gradient(to bottom, #d97706, #b45309); border: none; padding: 15px 60px; color: white;
            font-family: 'Cinzel', serif; font-size: 1.5rem; font-weight: bold;
            cursor: pointer; border-radius: 50px; box-shadow: 0 4px 0 #78350f, 0 0 20px rgba(0,0,0,0.5);
            transition: transform 0.1s; text-transform: uppercase;
        }
        #roll-btn:active { transform: translateY(4px); box-shadow: 0 0 0 #78350f; }
        #roll-btn:disabled { background: #475569; box-shadow: none; cursor: not-allowed; opacity: 0.5; transform: translateY(4px); }

        /* Tooltip Mouse Hover */
        #tooltip {
            position: fixed; pointer-events: none; z-index: 60;
            background: rgba(15, 23, 42, 0.95); border: 1px solid #fbbf24;
            padding: 10px 15px; border-radius: 6px; color: white;
            font-size: 0.9rem; display: none; transform: translate(20px, 20px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.5); border-left: 4px solid #10b981;
            max-width: 250px;
        }
        #tooltip strong { color: #fbbf24; display: block; font-family: 'Cinzel', serif; font-size: 0.8rem; margin-bottom: 2px; }
        .tt-type { font-size: 0.7rem; text-transform: uppercase; letter-spacing: 1px; color: #94a3b8; }

        /* Modal */
        #modal-overlay {
            position: fixed; inset: 0; background: rgba(0,0,0,0.85); z-index: 100;
            display: none; align-items: center; justify-content: center; pointer-events: auto; backdrop-filter: blur(5px);
        }
        .modal-box {
            background: #1e293b; color: #f1f5f9; max-width: 600px; width: 90%;
            padding: 0; border-radius: 16px; text-align: center;
            border: 2px solid #475569; box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            overflow: hidden; animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .modal-header { padding: 20px; font-family: 'Cinzel', serif; font-size: 1.5rem; font-weight: bold; text-transform: uppercase; }
        .modal-content { padding: 20px; font-size: 1.1rem; line-height: 1.6; }
        .bg-quiz { background: #0f172a; border-bottom: 4px solid #3b82f6; }
        .bg-fact { background: #064e3b; border-bottom: 4px solid #10b981; }
        .bg-disaster { background: #450a0a; border-bottom: 4px solid #ef4444; }
        
        .quiz-options { display: flex; flex-direction: column; gap: 10px; padding: 20px; background: #0f172a; }
        .quiz-btn {
            background: #334155; border: 2px solid #475569; padding: 15px; width: 100%;
            font-family: 'Roboto', sans-serif; color: white; cursor: pointer; text-align: left;
            border-radius: 8px; transition: all 0.2s; font-weight: 500;
        }
        .quiz-btn:hover { background: #475569; border-color: #fbbf24; transform: translateX(5px); }
        .close-btn {
            background: #10b981; border: none; padding: 12px 30px; margin: 20px;
            color: #064e3b; font-weight: bold; cursor: pointer; border-radius: 50px; font-size: 1rem;
        }
        
        @keyframes popIn { from { transform: scale(0.9); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        
        #disaster-fx { position: fixed; inset: 0; pointer-events: none; z-index: 40; opacity: 0; transition: opacity 0.5s; mix-blend-mode: overlay; }
    </style>
    <!-- Three.js & OrbitControls -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

    <!-- 1. TITLE SCREEN -->
    <div id="title-screen" class="screen">
        <h1>JUMANJI</h1>
        <h2>Geo-Literacy & Environment Edition</h2>
        <div class="creator-name">Sensei Angga Conni Saputra - 2026</div>
        <button class="big-btn" onclick="app.showSetup()">START CLASS</button>
    </div>

    <!-- 2. SETUP SCREEN -->
    <div id="setup-screen" class="screen hidden">
        <h2>PILIH JUMLAH SISWA</h2>
        <div class="player-select">
            <button class="p-opt-btn" onclick="app.startGame(1)">1</button>
            <button class="p-opt-btn" onclick="app.startGame(2)">2</button>
            <button class="p-opt-btn" onclick="app.startGame(3)">3</button>
            <button class="p-opt-btn" onclick="app.startGame(4)">4</button>
            <button class="p-opt-btn" onclick="app.startGame(5)">5</button>
            <button class="p-opt-btn" onclick="app.startGame(6)">6</button>
        </div>
    </div>

    <!-- 3. GAME UI -->
    <div id="ui-layer">
        <div class="hud-top">
            <div>
                <h3 class="mini-title">JUMANJI 3D</h3>
                <small style="color:#94a3b8">Mouse: Zoom/Rotate | Hover Tile untuk Info</small>
            </div>
            <div class="player-list" id="player-list-ui"></div>
        </div>

        <div class="hud-bottom">
            <div id="log-area">Selamat datang! Siap belajar sambil berpetualang?</div>
            <button id="roll-btn" onclick="game.rollDice()">ROLL DICE</button>
        </div>
    </div>

    <!-- MOUSE TOOLTIP -->
    <div id="tooltip"></div>

    <!-- MODAL & FX -->
    <div id="modal-overlay"><div class="modal-box" id="modal-content"></div></div>
    <div id="disaster-fx"></div>

    <script>
        /** --- 0. SOUND MANAGER (WEB AUDIO API) --- */
        class SoundManager {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.enabled = false;
            }

            resume() {
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
                this.enabled = true;
            }

            // Helper for Tone
            playTone(freq, type, duration, startTime=0) {
                if (!this.enabled) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.value = freq;
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start(this.ctx.currentTime + startTime);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime + startTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + startTime + duration);
                osc.stop(this.ctx.currentTime + startTime + duration);
            }

            // 1. START GAME (Futuristic Rise)
            playStart() {
                this.resume();
                this.playTone(220, 'sine', 0.5, 0);   // A3
                this.playTone(440, 'sine', 0.5, 0.2); // A4
                this.playTone(880, 'sine', 1.0, 0.4); // A5
            }

            // 2. ROLL DICE (Rattle Noise)
            playRoll() {
                if (!this.enabled) return;
                const bufferSize = this.ctx.sampleRate * 0.5; // 0.5 sec
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const gain = this.ctx.createGain();
                gain.gain.value = 0.1;
                // Filter to make it sound less harsh
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 1000;

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);
                noise.start();
            }

            // 3. CORRECT (Ding!)
            playCorrect() {
                this.playTone(600, 'sine', 0.3, 0);
                this.playTone(1200, 'sine', 0.6, 0.1);
            }

            // 4. WRONG (Buzz)
            playWrong() {
                this.playTone(150, 'sawtooth', 0.4, 0);
                this.playTone(100, 'sawtooth', 0.4, 0.2);
            }

            // 5. DISASTER (Rumble)
            playDisaster() {
                this.playTone(80, 'square', 1.0, 0);
                this.playTone(60, 'sawtooth', 1.5, 0.2);
                this.playTone(50, 'sine', 2.0, 0);
            }
        }

        const sfx = new SoundManager();

        /** --- 1. GAME DATA (160 TILES - MASTER LIST) --- */
        const CONFIG = {
            totalTiles: 160,
            spiralTurns: 4.5,    
            innerRadius: 20,     
            outerRadius: 100,     
            tileSize: 3.5
        };

        const ZONES = [
            { start: 1, end: 20, color: 0x065f46, name: "ZONA A: HULU & HUJAN" }, // Emerald
            { start: 21, end: 40, color: 0x334155, name: "ZONA B: SUNGAI & KOTA" }, // Slate
            { start: 41, end: 60, color: 0xb45309, name: "ZONA C: DELTA & PESISIR" }, // Amber
            { start: 61, end: 80, color: 0x14532d, name: "ZONA D: MANGROVE" }, // Green
            { start: 81, end: 100, color: 0x1e3a8a, name: "ZONA E: LAUT & IKLIM" }, // Blue
            { start: 101, end: 160, color: 0x7c2d12, name: "ZONA F: SOLUSI & RESILIENSI" } // Orange/Brown
        ];

        // TIPE: 'Q' (Quiz), 'F' (Fact), 'D' (Disaster), 'P' (Policy)
        // DATA DIISI SESUAI SILABUS SENSEI ANGGA
        const TILE_DATA = {
            // --- ZONA A ---
            1: { t: 'F', q: "Siklus Air Global", d: "Air di bumi terus berputar dari laut, ke atmosfer, ke darat, dan kembali ke laut. Jumlah air di bumi relatif tetap." },
            2: { t: 'Q', q: "Penyebab utama banjir bandang di hulu adalah...", o: ["Curah hujan rendah", "Alih fungsi hutan (Deforestasi)", "Sungai yang lebar"], a: 1, fx: "FLOOD" },
            3: { t: 'F', q: "Peran Vegetasi", d: "Akar pohon membantu tanah menyerap air (infiltrasi), mencegah air langsung lari ke permukaan (runoff)." },
            4: { t: 'Q', q: "Apa dampak langsung deforestasi terhadap tanah?", o: ["Tanah jadi subur", "Erosi dan Longsor", "Air tanah bertambah"], a: 1, fx: "LANDSLIDE" },
            5: { t: 'D', q: "LONGSOR KECIL!", d: "Tanah labil runtuh menimpa jalurmu.", fx: "LANDSLIDE" },
            6: { t: 'F', q: "Jenis Tanah", d: "Tanah berpasir menyerap air cepat, tanah lempung lambat menyerap air (mudah genang)." },
            7: { t: 'Q', q: "Air hujan yang mengalir di permukaan tanah disebut...", o: ["Infiltrasi", "Runoff (Limpasan)", "Evaporasi"], a: 1, fx: "FLOOD" },
            9: { t: 'Q', q: "Mengapa lereng terjal rawan longsor?", o: ["Gravitasi & tanah jenuh air", "Banyak pohon", "Angin kencang"], a: 0, fx: "LANDSLIDE" },
            10: { t: 'P', q: "KEBIJAKAN: Hutan di hulu mau dijadikan Villa atau Hutan Lindung?", o: ["Bangun Villa (Ekonomi)", "Hutan Lindung (Ekologi)"], a: 1, fx: "LANDSLIDE" },
            15: { t: 'D', q: "HUJAN EKSTREM LOKAL!", d: "Air bah tiba-tiba datang dari hulu.", fx: "FLOOD" },
            20: { t: 'D', q: "LONGSOR BESAR!", d: "Lereng gunung runtuh total!", fx: "LANDSLIDE" },

            // --- ZONA B ---
            21: { t: 'F', q: "Sistem Sungai", d: "Sungai bukan tempat sampah! Sungai adalah nadi kehidupan yang mengalirkan air dari hulu ke hilir." },
            22: { t: 'Q', q: "Sampah plastik di sungai akhirnya akan bermuara di...", o: ["Hilang sendiri", "Laut (jadi Mikroplastik)", "Langit"], a: 1, fx: "OCEAN" },
            23: { t: 'D', q: "DRAINASE TERSUMBAT!", d: "Sampah menumpuk, air meluap ke jalan.", fx: "FLOOD" },
            25: { t: 'Q', q: "Kenapa betonisasi kota memperparah banjir?", o: ["Air tidak bisa meresap ke tanah", "Jalan jadi licin", "Kota jadi panas"], a: 0, fx: "FLOOD" },
            28: { t: 'D', q: "BANJIR KOTA!", d: "Sistem drainase kota gagal menampung hujan.", fx: "FLOOD" },
            29: { t: 'F', q: "Urban Heat Island", d: "Kota lebih panas dari desa karena beton dan aspal menyerap panas matahari." },
            33: { t: 'P', q: "KEBIJAKAN: Lahan kosong dijadikan Parkiran atau Taman Kota (RTH)?", o: ["Parkiran (Beton)", "Taman Kota (Resapan)"], a: 1, fx: "FLOOD" },
            36: { t: 'D', q: "TANGGUL JEBOL!", d: "Debit air melebihi kapasitas tanggul.", fx: "FLOOD" },
            40: { t: 'D', q: "BANJIR BESAR PERKOTAAN!", d: "Lumpuh total akibat salah tata ruang.", fx: "FLOOD" },

            // --- ZONA C ---
            41: { t: 'F', q: "Delta Sungai", d: "Endapan sedimen di muara sungai yang subur namun rawan tenggelam." },
            43: { t: 'D', q: "PASANG TINGGI!", d: "Air laut naik ke daratan lebih tinggi dari biasanya.", fx: "OCEAN" },
            45: { t: 'Q', q: "Abrasi pantai terjadi karena...", o: ["Terlalu banyak ikan", "Hilangnya hutan bakau & hantaman ombak", "Pasir dijual"], a: 1, fx: "MANGROVE" },
            46: { t: 'F', q: "Land Subsidence", d: "Penurunan muka tanah akibat penyedotan air tanah berlebihan di pesisir." },
            48: { t: 'D', q: "BANJIR ROB!", d: "Air laut masuk ke daratan saat pasang.", fx: "OCEAN" },
            53: { t: 'P', q: "KEBIJAKAN: Tambak Udang Intensif atau Tambak Silvofishery (Mangrove)?", o: ["Intensif (Cepat Untung)", "Lestari (Jangka Panjang)"], a: 1, fx: "MANGROVE" },
            56: { t: 'D', q: "ABRASI PARAH!", d: "Garis pantai mundur drastis, rumah hanyut.", fx: "MANGROVE" },
            60: { t: 'D', q: "PESISIR RUSAK!", d: "Ekosistem pesisir hancur lebur.", fx: "OCEAN" },

            // --- ZONA D ---
            61: { t: 'F', q: "Jenis Mangrove", d: "Ada Rhizophora (akar tunjang), Avicennia (akar napas), dan Sonneratia." },
            62: { t: 'Q', q: "Fungsi utama akar mangrove adalah...", o: ["Hiasan pantai", "Menahan sedimen & cegah abrasi", "Racun ikan"], a: 1, fx: "MANGROVE" },
            63: { t: 'D', q: "MANGROVE DITEBANG!", d: "Pertahanan pantai hilang seketika.", fx: "MANGROVE" },
            66: { t: 'F', q: "Blue Carbon", d: "Mangrove menyimpan karbon 3-5x lebih banyak daripada hutan hujan tropis!" },
            68: { t: 'D', q: "ABRASI MENINGKAT!", d: "Tanpa mangrove, ombak memakan daratan.", fx: "MANGROVE" },
            73: { t: 'P', q: "KEBIJAKAN: Reklamasi Pantai atau Restorasi Mangrove?", o: ["Reklamasi (Beton)", "Restorasi (Hijau)"], a: 1, fx: "OCEAN" },
            76: { t: 'D', q: "EKOSISTEM RUNTUH!", d: "Tidak ada ikan, tidak ada pelindung.", fx: "SNAKE" },
            80: { t: 'D', q: "KEHILANGAN MANGROVE BESAR!", d: "Bencana ekologis skala besar.", fx: "MANGROVE" },

            // --- ZONA E ---
            81: { t: 'F', q: "Laut & Panas", d: "Laut menyerap 90% kelebihan panas akibat pemanasan global." },
            82: { t: 'Q', q: "Kenaikan muka air laut (Sea Level Rise) disebabkan oleh...", o: ["Ikan bertambah banyak", "Mencairnya es kutub & pemuaian air", "Kapal selam"], a: 1, fx: "OCEAN" },
            83: { t: 'D', q: "BADAI LAUT!", d: "Suhu laut hangat memicu badai tropis.", fx: "OCEAN" },
            88: { t: 'D', q: "CORAL BLEACHING!", d: "Terumbu karang memutih dan mati karena laut panas.", fx: "OCEAN" },
            90: { t: 'Q', q: "Apa dampak CO2 berlebih pada laut?", o: ["Laut jadi manis", "Asidifikasi (Laut jadi asam)", "Laut jadi biru"], a: 1, fx: "OCEAN" },
            96: { t: 'D', q: "EKOSISTEM LAUT RUSAK!", d: "Rantai makanan di laut putus.", fx: "OCEAN" },
            100: { t: 'D', q: "KRISIS LAUT!", d: "Laut sekarat, manusia terancam.", fx: "OCEAN" },

            // --- ZONA F (101-160) ---
            101: { t: 'F', q: "Nature-based Solutions", d: "Solusi berbasis alam: menggunakan proses alam untuk mengatasi masalah bencana." },
            108: { t: 'D', q: "BENCANA BERULANG!", d: "Kita tidak belajar dari sejarah.", fx: "FLOOD" },
            115: { t: 'Q', q: "Kolaborasi Pentahelix melibatkan siapa saja?", o: ["Hanya Pemerintah", "Pemerintah, Warga, Akademisi, Bisnis, Media", "Hanya LSM"], a: 1, fx: "LANDSLIDE" },
            120: { t: 'D', q: "KRISIS IKLIM LOKAL!", d: "Cuaca tidak menentu, panen gagal.", fx: "OCEAN" },
            128: { t: 'D', q: "GAGAL KESIAPSIAGAAN!", d: "Peringatan dini tidak sampai ke warga.", fx: "FLOOD" },
            136: { t: 'D', q: "TEKANAN POPULASI!", d: "Daya dukung lingkungan terlampaui.", fx: "LANDSLIDE" },
            140: { t: 'D', q: "DAMPAK MASA DEPAN!", d: "Generasi mendatang menanggung akibatnya.", fx: "OCEAN" },
            146: { t: 'D', q: "UJIAN SISTEM!", d: "Apakah infrastruktur kita tahan bencana?", fx: "FLOOD" },
            154: { t: 'D', q: "KRISIS TERAKHIR!", d: "Ujian terakhir sebelum keseimbangan pulih.", fx: "OCEAN" },
            160: { t: 'F', q: "ECOSYSTEM RESTORED!", d: "Selamat! Kamu telah memulihkan keseimbangan alam." }
        };

        const PLAYER_COLORS = [0xef4444, 0x3b82f6, 0x22c55e, 0xeab308, 0xa855f7, 0xf97316];
        const PLAYER_NAMES = ["Merah", "Biru", "Hijau", "Kuning", "Ungu", "Jingga"];

        /** --- 3D ENGINE --- */
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020617); // Dark Slate Blue night
        // Kabut estetik (Exp2) - Mulai agak jauh agar papan jelas
        scene.fog = new THREE.FogExp2(0x020617, 0.005); 

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 120, 100); 
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2.2; 
        controls.minDistance = 30;
        controls.maxDistance = 250;

        /** --- LIGHTING (TERANG & JELAS) --- */
        
        // 1. Matahari (Directional) - Kuat
        const dirLight = new THREE.DirectionalLight(0xffffff, 5.0); // Intensitas 5.0!
        dirLight.position.set(80, 150, -80); 
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 4096;
        dirLight.shadow.mapSize.height = 4096;
        // Perluas area shadow
        const d = 200;
        dirLight.shadow.camera.left = -d;
        dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d;
        dirLight.shadow.camera.bottom = -d;
        scene.add(dirLight);

        // 2. Ambient (Isi bayangan)
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8); 
        scene.add(ambientLight);

        // 3. Hemisphere (Langit vs Tanah)
        const hemiLight = new THREE.HemisphereLight(0x88ccff, 0x442200, 0.6); 
        scene.add(hemiLight);

        // 4. Glow Monitor
        const centerLight = new THREE.PointLight(0x10b981, 2.0, 80);
        centerLight.position.set(0, 15, 0);
        scene.add(centerLight);

        // 5. Sun Sprite (Visual Matahari)
        const sunCanvas = document.createElement('canvas');
        sunCanvas.width = 64; sunCanvas.height = 64;
        const ctxSun = sunCanvas.getContext('2d');
        const gradSun = ctxSun.createRadialGradient(32,32,10,32,32,32);
        gradSun.addColorStop(0, 'white');
        gradSun.addColorStop(0.4, 'rgba(255, 255, 0, 1)');
        gradSun.addColorStop(1, 'rgba(255, 160, 0, 0)');
        ctxSun.fillStyle = gradSun;
        ctxSun.fillRect(0,0,64,64);
        const sunTex = new THREE.CanvasTexture(sunCanvas);
        const sunSprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: sunTex, color: 0xffddaa, blending: THREE.AdditiveBlending }));
        sunSprite.scale.set(80, 80, 1);
        sunSprite.position.set(80, 150, -80).normalize().multiplyScalar(180); // Jauh di langit
        scene.add(sunSprite);


        /** --- ENVIRONMENT: WATER & FOG MIST --- */
        
        // Water Plane
        const waterGeo = new THREE.PlaneGeometry(600, 600, 128, 128);
        const waterMat = new THREE.MeshPhongMaterial({
            color: 0x0077be,
            emissive: 0x001133,
            specular: 0x111111,
            shininess: 100,
            transparent: true,
            opacity: 0.9,
            side: THREE.DoubleSide
        });
        const waterMesh = new THREE.Mesh(waterGeo, waterMat);
        waterMesh.rotation.x = -Math.PI / 2;
        waterMesh.position.y = -2; // Dekat dengan tile
        waterMesh.receiveShadow = true;
        scene.add(waterMesh);
        
        // Groups
        const fxGroup = new THREE.Group();
        scene.add(fxGroup);
        const fogGroup = new THREE.Group();
        scene.add(fogGroup);

        /** --- APP LOGIC --- */
        const app = {
            showSetup: () => {
                sfx.resume(); // Enable audio context on click
                sfx.playStart();
                document.getElementById('title-screen').classList.add('hidden');
                document.getElementById('setup-screen').classList.remove('hidden');
            },
            startGame: (num) => {
                document.getElementById('setup-screen').classList.add('hidden');
                document.getElementById('ui-layer').classList.add('ui-visible');
                
                window.game = new Game(num);
                
                // Camera Intro
                const startY = 250;
                const endY = camera.position.y;
                camera.position.set(0, startY, 0);
                controls.target.set(0,0,0);
                
                let t = 0;
                const introAnim = () => {
                    t += 0.008;
                    camera.position.y = THREE.MathUtils.lerp(startY, endY, t);
                    camera.position.z = THREE.MathUtils.lerp(10, 100, t);
                    if(t < 1) requestAnimationFrame(introAnim);
                };
                introAnim();
            }
        };

        /** --- GAME CLASS --- */
        class Game {
            constructor(numPlayers) {
                this.players = [];
                for(let i=0; i<numPlayers; i++) {
                    this.players.push({ 
                        id: i, name: PLAYER_NAMES[i], color: PLAYER_COLORS[i], pos: 1, mesh: null 
                    });
                }
                
                this.turn = 0;
                this.isAnimating = false;
                this.tiles = []; 
                this.tileMeshes = []; 
                this.resolvedTiles = new Set();
                this.waterTime = 0; 
                this.waterSurge = 0; 

                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.hoveredTile = null;

                // Monitor Texture
                this.monitorCanvas = document.createElement('canvas');
                this.monitorCanvas.width = 512;
                this.monitorCanvas.height = 512;
                this.monitorContext = this.monitorCanvas.getContext('2d');
                this.monitorTexture = new THREE.CanvasTexture(this.monitorCanvas);
                this.monitorSprite = null; 
                this.diceMesh = null;
                
                this.initBoardSpiral();
                this.initCenterMonitor();
                this.initPlayers();
                this.initDice(); 
                this.initAtmosphericFog();
                this.updateUI();
                this.updatePlayerPositions(1, true);

                this.drawRadar("READY", "#10b981");

                window.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.animate();
            }

            // --- ATMOSPHERIC FOG (KABUT ESTETIK) ---
            initAtmosphericFog() {
                // Tekstur kabut lembut
                const canvas = document.createElement('canvas');
                canvas.width = 128; canvas.height = 128;
                const ctx = canvas.getContext('2d');
                const grad = ctx.createRadialGradient(64,64,0, 64,64,64);
                grad.addColorStop(0, 'rgba(200, 220, 255, 0.15)'); 
                grad.addColorStop(1, 'rgba(200, 220, 255, 0)');
                ctx.fillStyle = grad;
                ctx.fillRect(0,0,128,128);
                const fogTex = new THREE.CanvasTexture(canvas);
                const fogMat = new THREE.SpriteMaterial({ map: fogTex, color: 0xccddff, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false });

                // Partikel kabut melayang rendah
                for(let i=0; i<200; i++) {
                    const sprite = new THREE.Sprite(fogMat);
                    sprite.position.set(
                        (Math.random() - 0.5) * 300,
                        -1 + Math.random() * 4, // Rendah di atas air
                        (Math.random() - 0.5) * 300
                    );
                    sprite.scale.set(40, 20, 1);
                    sprite.userData = { velX: (Math.random()-0.5)*0.03, velZ: (Math.random()-0.5)*0.03 };
                    fogGroup.add(sprite);
                }
            }

            animateFog() {
                fogGroup.children.forEach(s => {
                    s.position.x += s.userData.velX;
                    s.position.z += s.userData.velZ;
                    if(Math.abs(s.position.x) > 150) s.position.x *= -0.9;
                    if(Math.abs(s.position.z) > 150) s.position.z *= -0.9;
                });
            }

            // --- DICE ---
            createDiceTextures() {
                const materials = [];
                for (let i = 1; i <= 6; i++) {
                    const c = document.createElement('canvas');
                    c.width = 128; c.height = 128;
                    const ctx = c.getContext('2d');
                    ctx.fillStyle = '#f8fafc'; ctx.fillRect(0,0,128,128); // Putih tulang
                    ctx.strokeStyle = '#cbd5e1'; ctx.lineWidth = 8; ctx.strokeRect(0,0,128,128);
                    ctx.fillStyle = '#1e293b'; // Dot hitam
                    const dot = (x,y) => { ctx.beginPath(); ctx.arc(x,y,14,0,Math.PI*2); ctx.fill(); };
                    const m=64, s=32, e=96;
                    if(i%2) dot(m,m);
                    if(i>1){ dot(s,s); dot(e,e); }
                    if(i>3){ dot(e,s); dot(s,e); }
                    if(i===6){ dot(s,m); dot(e,m); }
                    materials.push(new THREE.MeshStandardMaterial({ map: new THREE.CanvasTexture(c) }));
                }
                return [materials[0], materials[5], materials[1], materials[4], materials[2], materials[3]];
            }

            initDice() {
                this.diceMesh = new THREE.Mesh(new THREE.BoxGeometry(5,5,5), this.createDiceTextures());
                this.diceMesh.castShadow = true;
                this.diceMesh.visible = false;
                scene.add(this.diceMesh);
            }

            animateDiceRoll(roll, cb) {
                this.diceMesh.visible = true;
                this.diceMesh.position.set(0, 80, 0);
                this.diceMesh.rotation.set(Math.random()*6, Math.random()*6, Math.random()*6);
                sfx.playRoll(); // PLAY SOUND
                
                // Mapping rotasi target (Top Face)
                const rots = { 1:[0,0,1.57], 6:[0,0,-1.57], 2:[0,0,0], 5:[3.14,0,0], 3:[-1.57,0,0], 4:[1.57,0,0] };
                const target = rots[roll] || [0,0,0];

                let start = Date.now();
                const anim = () => {
                    const p = (Date.now() - start) / 1500; // 1.5s total
                    if(p < 0.6) { // Drop & Spin
                        this.diceMesh.position.y = THREE.MathUtils.lerp(80, 15, p*1.6);
                        this.diceMesh.rotation.x += 0.3; this.diceMesh.rotation.y += 0.2;
                    } else if (p < 1) { // Hover & Align
                        this.diceMesh.position.y = 15 + Math.sin(p*20);
                        this.diceMesh.rotation.x = THREE.MathUtils.lerp(this.diceMesh.rotation.x, target[0], 0.1);
                        this.diceMesh.rotation.y = THREE.MathUtils.lerp(this.diceMesh.rotation.y, target[1], 0.1);
                        this.diceMesh.rotation.z = THREE.MathUtils.lerp(this.diceMesh.rotation.z, target[2], 0.1);
                    } else { // Finish
                        this.diceMesh.rotation.set(...target);
                        setTimeout(() => this.animateDiceExit(cb), 500);
                        return;
                    }
                    requestAnimationFrame(anim);
                };
                anim();
            }

            animateDiceExit(cb) {
                let y = 15;
                const drop = () => {
                    y -= 1; this.diceMesh.position.y = y; this.diceMesh.rotation.y += 0.1;
                    if(y > -20) requestAnimationFrame(drop);
                    else { this.diceMesh.visible = false; cb(); }
                };
                drop();
            }

            // --- RADAR MONITOR (HOLOGRAPHIC) ---
            drawRadar(text, color) {
                const ctx = this.monitorContext;
                const w = 512, h = 512;
                ctx.clearRect(0,0,w,h);
                
                // Background glassy
                ctx.fillStyle = 'rgba(0,20,10,0.5)'; ctx.fillRect(0,0,w,h);
                // Scanlines
                ctx.fillStyle = 'rgba(50,255,100,0.1)';
                for(let i=0; i<h; i+=6) ctx.fillRect(0,i,w,2);
                
                // Border Tech
                ctx.strokeStyle = color; ctx.lineWidth = 8;
                ctx.strokeRect(20,20,w-40,h-40);
                
                // Text
                ctx.fillStyle = color;
                ctx.font = 'bold 80px "Courier New"';
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.shadowColor = color; ctx.shadowBlur = 30;
                ctx.fillText(text, w/2, h/2);
                ctx.shadowBlur = 0;
                
                this.monitorTexture.needsUpdate = true;
            }

            // --- BOARD SETUP ---
            initBoardSpiral() {
                const geo = new THREE.BoxGeometry(CONFIG.tileSize, 1, CONFIG.tileSize * 1.5);
                const grp = new THREE.Group();
                const rootMat = new THREE.MeshStandardMaterial({ color: 0x3f2e22, roughness: 1 });

                for(let i=0; i<CONFIG.totalTiles; i++) {
                    const p = i/CONFIG.totalTiles;
                    const ang = p * CONFIG.spiralTurns * Math.PI * 2;
                    const rad = CONFIG.outerRadius - (p * (CONFIG.outerRadius - CONFIG.innerRadius));
                    const x = Math.cos(ang) * rad;
                    const z = Math.sin(ang) * rad;

                    const zone = ZONES.find(z => (i+1) >= z.start && (i+1) <= z.end);
                    const color = zone ? zone.color : 0x444444;
                    const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.5, metalness: 0.2 });
                    
                    const tile = new THREE.Mesh(geo, mat);
                    tile.position.set(x, 0, z);
                    tile.rotation.y = -ang;
                    tile.position.y = 2 + Math.random(); // Variasi tinggi
                    
                    tile.userData = { id: i+1, zone: zone.name, color: color };
                    tile.receiveShadow = true; tile.castShadow = true;
                    
                    // Akar Mangrove (Procedural)
                    const nRoot = 5 + Math.floor(Math.random()*5);
                    for(let k=0; k<nRoot; k++) {
                        const rH = 15 + Math.random()*10;
                        const rGeo = new THREE.CylinderGeometry(0.2, 0.05, rH, 4);
                        const root = new THREE.Mesh(rGeo, rootMat);
                        root.position.set(x+(Math.random()-0.5)*3, tile.position.y - rH/2, z+(Math.random()-0.5)*3);
                        root.rotation.set((Math.random()-0.5), Math.random()*3, (Math.random()-0.5));
                        grp.add(root);
                    }
                    
                    grp.add(tile);
                    this.tileMeshes.push(tile);
                    this.tiles.push(new THREE.Vector3(x, tile.position.y + 1.5, z));
                }
                scene.add(grp);
            }

            initCenterMonitor() {
                // Monitor fisik
                const base = new THREE.Mesh(new THREE.CylinderGeometry(15, 18, 2, 32), new THREE.MeshStandardMaterial({color:0x111}));
                base.position.y = -1; scene.add(base);
                
                // Hologram Sprite
                const mat = new THREE.SpriteMaterial({ map: this.monitorTexture, transparent: true, blending: THREE.AdditiveBlending });
                this.monitorSprite = new THREE.Sprite(mat);
                this.monitorSprite.scale.set(25, 25, 1);
                this.monitorSprite.position.set(0, 15, 0);
                scene.add(this.monitorSprite);
            }

            initPlayers() {
                // Pion: Cone + Sphere
                const geoB = new THREE.CylinderGeometry(0.5, 1, 2, 16);
                const geoH = new THREE.SphereGeometry(0.8, 16, 16);
                
                this.players.forEach(p => {
                    const grp = new THREE.Group();
                    const mat = new THREE.MeshStandardMaterial({ color: p.color, emissive: p.color, emissiveIntensity: 0.4 });
                    const body = new THREE.Mesh(geoB, mat); body.position.y = 1;
                    const head = new THREE.Mesh(geoH, mat); head.position.y = 2.5;
                    grp.add(body, head);
                    
                    grp.traverse(o=>{ if(o.isMesh) o.castShadow=true; });
                    grp.position.copy(this.tiles[0]);
                    scene.add(grp);
                    p.mesh = grp;
                });
            }

            // --- GAMEPLAY LOGIC ---
            rollDice() {
                if(this.isAnimating) return;
                this.isAnimating = true;
                const roll = Math.floor(Math.random()*6)+1;
                this.log(`ðŸŽ² ${this.players[this.turn].name} melempar dadu...`);
                this.drawRadar("ROLLING", "#fbbf24");
                
                this.animateDiceRoll(roll, () => {
                    this.drawRadar(roll.toString(), "#fbbf24");
                    this.movePlayer(this.turn, roll);
                });
            }

            movePlayer(pid, steps, isPenalty=false) {
                const p = this.players[pid];
                let target = (p.pos - 1) + (isPenalty ? -steps : steps);
                if(target >= CONFIG.totalTiles) target = CONFIG.totalTiles - 1;
                if(target < 0) target = 0;

                const start = p.mesh.position.clone();
                const end = this.tiles[target].clone();
                
                // Animasi Lompat
                let st = Date.now();
                const dur = 1000;
                const jump = () => {
                    const pr = Math.min((Date.now()-st)/dur, 1);
                    p.mesh.position.lerpVectors(start, end, pr);
                    p.mesh.position.y = Math.max(start.y, end.y) + Math.sin(pr*Math.PI)*8;
                    
                    if(pr<1) requestAnimationFrame(jump);
                    else {
                        p.pos = target + 1;
                        this.updatePlayerPositions(target);
                        this.isAnimating = false;
                        if(!isPenalty) this.checkEvent(pid);
                        else this.nextTurn();
                    }
                };
                jump();
            }

            checkEvent(pid) {
                const p = this.players[pid];
                const tid = p.pos;
                
                // Win?
                if(tid === CONFIG.totalTiles) {
                    this.showModal("ðŸ† YOU WIN!", `Selamat! ${p.name} telah memulihkan ekosistem!`, true);
                    return;
                }

                // Check Data
                const data = TILE_DATA[tid];
                
                if (data && !this.resolvedTiles.has(tid)) {
                    // Tipe Event
                    if (data.t === 'Q') { // Quiz
                        this.drawRadar("QUIZ", "#fbbf24");
                        this.showQuiz(p, data);
                    } else if (data.t === 'F') { // Fact
                        this.drawRadar("INFO", "#3b82f6");
                        this.showFact(p, data);
                    } else if (data.t === 'D') { // Disaster
                        this.drawRadar("BAHAYA!", "#ef4444");
                        this.triggerDisaster(p, data);
                    } else if (data.t === 'P') { // Policy
                        this.drawRadar("POLICY", "#fbbf24");
                        this.showQuiz(p, data); // Pakai UI Quiz
                    }
                } else {
                    this.log(`${p.name} aman di Tile ${tid}.`);
                    this.drawRadar("SAFE", "#10b981");
                    this.nextTurn();
                }
            }

            showQuiz(p, data) {
                const modal = document.getElementById('modal-content');
                modal.innerHTML = `
                    <div class="modal-header bg-quiz">TANTANGAN PENGETAHUAN</div>
                    <div class="modal-content">
                        <p>${data.q}</p>
                        <div class="quiz-options">
                            ${data.o.map((opt, i) => `
                                <button class="quiz-btn" onclick="game.answerQuiz(${i}, ${data.a}, '${data.fx}')">
                                    ${["A","B","C"][i]}. ${opt}
                                </button>
                            `).join('')}
                        </div>
                    </div>
                `;
                document.getElementById('modal-overlay').style.display = 'flex';
            }

            showFact(p, data) {
                const modal = document.getElementById('modal-content');
                modal.innerHTML = `
                    <div class="modal-header bg-fact">FAKTA LINGKUNGAN</div>
                    <div class="modal-content">
                        <p><strong>${data.q}</strong></p>
                        <p>${data.d}</p>
                        <button class="close-btn" onclick="game.closeModal()">PAHAM!</button>
                    </div>
                `;
                document.getElementById('modal-overlay').style.display = 'flex';
                this.resolvedTiles.add(p.pos); // Fact cuma sekali muncul
            }

            triggerDisaster(p, data) {
                sfx.playDisaster(); // PLAY SOUND
                this.log(`âš ï¸ BENCANA: ${data.q}`);
                
                // Visual FX
                if(data.fx === 'FLOOD') this.fxFlood(p.mesh.position);
                else if(data.fx === 'LANDSLIDE') this.fxLandslide(p.mesh.position);
                else if(data.fx === 'OCEAN') this.fxOcean();
                else this.fxShake();

                setTimeout(() => {
                    const pen = Math.floor(Math.random()*6)+1;
                    this.log(`ðŸŒŠ Terkena dampak! Mundur ${pen} langkah.`);
                    this.movePlayer(this.turn, pen, true);
                }, 2500);
            }

            answerQuiz(choice, correct, fxType) {
                document.getElementById('modal-overlay').style.display = 'none';
                if(choice === correct) {
                    sfx.playCorrect(); // PLAY SOUND
                    this.log("âœ… Jawaban BENAR! Tile aman.");
                    this.resolvedTiles.add(this.players[this.turn].pos);
                    this.drawRadar("BENAR", "#10b981");
                    this.nextTurn();
                } else {
                    sfx.playWrong(); // PLAY SOUND
                    this.log("âŒ Jawaban SALAH! Konsekuensi Alam terjadi!");
                    this.drawRadar("SALAH", "#ef4444");
                    
                    // Trigger FX based on answer context
                    if(fxType === 'FLOOD') this.fxFlood(this.players[this.turn].mesh.position);
                    else if(fxType === 'LANDSLIDE') this.fxLandslide(this.players[this.turn].mesh.position);
                    else this.fxShake();

                    setTimeout(() => {
                        this.drawRadar("PENALTI", "#ef4444");
                        // Dice Animation for Penalty
                        const pen = Math.floor(Math.random()*6)+1;
                        this.animateDiceRoll(pen, () => {
                            this.log(`Mundur ${pen} langkah.`);
                            this.movePlayer(this.turn, pen, true);
                        });
                    }, 2000);
                }
            }

            closeModal() {
                document.getElementById('modal-overlay').style.display = 'none';
                this.nextTurn();
            }

            nextTurn() {
                this.turn = (this.turn + 1) % this.players.length;
                this.updateUI();
            }

            updateUI() {
                const p = this.players[this.turn];
                document.getElementById('player-list-ui').innerHTML = this.players.map((pl, i) => 
                    `<div class="player-item ${i===this.turn?'active-turn':''}" style="opacity:${i===this.turn?1:0.6}">
                        <span class="p-dot" style="background:#${pl.color.toString(16)}"></span> ${pl.name} (T:${pl.pos})
                    </div>`
                ).join('');
                document.getElementById('roll-btn').disabled = this.isAnimating;
            }

            showModal(title, msg, isWin) {
                const modal = document.getElementById('modal-content');
                modal.innerHTML = `
                    <div class="modal-header" style="background:${isWin?'#fbbf24':'#ef4444'}">${title}</div>
                    <div class="modal-content"><p>${msg}</p><button class="close-btn" onclick="location.reload()">MAIN LAGI</button></div>
                `;
                document.getElementById('modal-overlay').style.display = 'flex';
            }

            // --- FX VISUALS ---
            spawnPart(col, count, pos) {
                const geo = new THREE.BufferGeometry();
                const arr = [];
                for(let i=0; i<count*3; i++) arr.push((Math.random()-0.5)*20 + (i%3===1?pos.y+20:pos.x));
                // Simplified particle logic due to length constraints, using cubes for debris
                for(let i=0; i<10; i++) {
                    const m = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshBasicMaterial({color:col}));
                    m.position.set(pos.x+(Math.random()-0.5)*10, pos.y+10+Math.random()*10, pos.z+(Math.random()-0.5)*10);
                    fxGroup.add(m);
                    const dest = -5;
                    let y = m.position.y;
                    const fall = () => {
                        y-=0.5; m.position.y=y; m.rotation.x+=0.1;
                        if(y>dest) requestAnimationFrame(fall); else fxGroup.remove(m);
                    };
                    fall();
                }
            }

            fxFlood(pos) {
                this.spawnPart(0x3b82f6, 20, pos); // Blue debris
                let t=0;
                const surge = () => {
                    t+=0.1; this.waterSurge = Math.sin(t)*8;
                    if(t<Math.PI) requestAnimationFrame(surge); else this.waterSurge=0;
                }
                surge();
            }
            
            fxLandslide(pos) {
                this.spawnPart(0x78350f, 20, pos); // Brown debris
                this.fxShake();
            }

            fxOcean() {
                this.waterSurge = 5; // High waves
                setTimeout(()=>this.waterSurge=0, 2000);
            }

            fxShake() {
                const orig = camera.position.clone();
                let t=0;
                const shk = () => {
                    t++;
                    camera.position.x = orig.x + (Math.random()-0.5)*2;
                    if(t<20) requestAnimationFrame(shk); else camera.position.copy(orig);
                }
                shk();
            }

            // --- CORE LOOP ---
            onMouseMove(e) {
                this.mouse.x = (e.clientX/window.innerWidth)*2-1;
                this.mouse.y = -(e.clientY/window.innerHeight)*2+1;
                const tt = document.getElementById('tooltip');
                tt.style.left = e.clientX + 'px'; tt.style.top = e.clientY + 'px';
            }

            checkHover() {
                this.raycaster.setFromCamera(this.mouse, camera);
                const intersects = this.raycaster.intersectObjects(this.tileMeshes);
                const tt = document.getElementById('tooltip');
                
                if(intersects.length > 0) {
                    const d = intersects[0].object.userData;
                    if(this.hoveredTile !== intersects[0].object) {
                        this.hoveredTile = intersects[0].object;
                        this.hoveredTile.material.emissive.setHex(0xaaaaaa);
                        tt.style.display = 'block';
                        // Ambil info dari TILE_DATA jika ada
                        const info = TILE_DATA[d.id];
                        let desc = d.zone;
                        if(info) desc += `<br><span style="color:#fff">${info.q}</span>`;
                        
                        tt.innerHTML = `<strong>TILE ${d.id}</strong>${desc}`;
                        
                        if(!this.isAnimating) this.drawRadar(`TILE ${d.id}`, d.color);
                    }
                } else {
                    if(this.hoveredTile) {
                        this.hoveredTile.material.emissive.setHex(0);
                        this.hoveredTile = null;
                        tt.style.display = 'none';
                        if(!this.isAnimating) this.drawRadar("SCANNING", "#10b981");
                    }
                }
            }

            updatePlayerPositions(tid) {
                // Simple stack prevention
                const map = {};
                this.players.forEach(p => {
                    if(!map[p.pos]) map[p.pos]=[];
                    map[p.pos].push(p);
                });
                Object.keys(map).forEach(k => {
                    const arr = map[k];
                    const center = this.tiles[arr[0].pos-1] || new THREE.Vector3();
                    arr.forEach((p, i) => {
                        if(arr.length===1) { p.mesh.position.copy(center); return; }
                        const ang = (i/arr.length)*Math.PI*2;
                        p.mesh.position.set(center.x+Math.cos(ang)*2, center.y, center.z+Math.sin(ang)*2);
                    });
                });
            }

            log(msg) {
                const el = document.getElementById('log-area');
                el.innerHTML = `> ${msg}<br>` + el.innerHTML;
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                controls.update();
                this.checkHover();
                this.animateFog();
                
                this.waterTime += 0.015;
                if(waterMesh) {
                    const pos = waterMesh.geometry.attributes.position.array;
                    for(let i=0; i<pos.length; i+=3) {
                        const x = pos[i]; const y = pos[i+1];
                        pos[i+2] = this.waterSurge + Math.sin(x/15 + this.waterTime)*1.5 + Math.cos(y/15 + this.waterTime)*1.5;
                    }
                    waterMesh.geometry.attributes.position.needsUpdate = true;
                }
                renderer.render(scene, camera);
            }
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>